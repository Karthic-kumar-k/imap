name:                 imap
version:              0.3.0.8
visibility:           public
id:                   imap-0.3.0.8-inplace
key:                  imap-0.3.0.8-inplace
license:              BSD-3-Clause
maintainer:           michal@monad.cat
author:               Michal Kawalec
synopsis:             An efficient IMAP client library, with SSL and streaming
description:
    This is an IMAP library for Haskell that aims to be efficient, easy to use, transparent when it comes to underlying libraries and support results streaming. To this end it employs `ListT`, so you can use it with any concurrency management library of your choosing.

    It tries to implement <https://tools.ietf.org/html/rfc3501 RFC-3501> as faithfully as possible, diverging from it where we noticed that servers have different ideas. If you want to understand this library, it's highly recommended to skim through that RFC first.

    /Usage/

    For a description of types used in this tutorial or an in-depth description of functions presented, please check the documentation or the source code.

    All of the commands will output their results in `ListT` and `MonadIO`. Results consist of a list of `UntaggedResult`s followed by a single `TaggedResult` that describes the command state (if it succeeded or failed).

    We provide a helper function that simplifies the output types for the cases when you don't care about the streaming and just want a list of `UntaggedResult`s or an error message. Depending on your needs you will probably use it for all the commands that are not `FETCH`.

    Also, remember that you probably have to keep the connection alive so that the server doesn't disconnect you. Send a `noop` from time to time to achieve that.

    /Simple, no streaming/

    You need a connection object first, so that you can execute commands on it. It's produced by `connectServer`, which accepts parameters from <https://hackage.haskell.org/package/connection-0.2.5/docs/Network-Connection.html Network.Connection>. Say you want to connect to gmail:

    > import Network.Connection
    > import Network.IMAP
    > import Network.IMAP.Types

    > let tls = TLSSettingsSimple False False False
    > let params = ConnectionParams "imap.gmail.com" 993 (Just tls) Nothing
    > conn <- connectServer params Nothing

    From now on you can run commands on this connection. The second parameter to `connectServer` is `Maybe IMAPSettings`. If settings are not provided, sane defaults will be used. We will use the `simpleFormat` helper function to convert from `ListT` to `IO`. Let's log in:

    >   simpleFormat $ login conn "mylogin" "mypass"
    >    Right [Capabilities [CIMAP4,CUnselect,CIdle,CNamespace,CQuota,CId,CExperimental "XLIST",CChildren,CExperimental "X-GM-EXT-1",CUIDPlus,CCompress "DEFLATE",CEnable,CMove,CCondstore,CEsearch,CUtf8 "ACCEPT",CListExtended,CListStatus,CAppendLimit 35882577]]

    You can see that the server replied with a `CAPABILITIES` reply and the login was successful. Next, let's select an inbox:

    >   simpleFormat $ select conn "inbox2"
    >    Left "[NONEXISTENT] Unknown Mailbox: inbox2 (Failure)"

    Oh, let's fix that

    >   simpleFormat $ select conn "inbox"
    >    Right [Flags [FAnswered,FFlagged,FDraft,FDeleted,FSeen,FOther "$NotPhishing",FOther "$Phishing",FOther "NonJunk"],PermanentFlags [FAnswered,FFlagged,FDraft,FDeleted,FSeen,FOther "$NotPhishing",FOther "$Phishing",FOther "NonJunk",FAny],UIDValidity 1,Exists 65,Recent 0,UIDNext 1050,HighestModSeq 251971]

    Again you can use the metadata if you wish to. Let's see what messages we have (<https://tools.ietf.org/html/rfc3501#section-6.4.4 consult the RFC> if you're unsure about the parameter to `uidSearch`):

    >   simpleFormat $ uidSearch conn "ALL"
    >    Right [Search [105,219,411,424,425,748,763,770,774,819,824,825,..]]

    Fetching a message is straigtforward as well:

    >   simpleFormat $ uidFetch conn "219"
    >   Right [Fetch [MessageId 2,UID 219,Body "Delivered-To: michal@monad.cat\r\nReceived: by...

    If you need more control on the parameters of fetch, there is a more general function available:

    >   simpleFormat $ uidFetchG conn "219 ALL"


    Do you want multiple messages in one reply? That's easy with [UID ranges](https://tools.ietf.org/html/rfc3501#section-6.4.8)!

    >   simpleFormat $ uidFetchG conn "219:9000 RFC822.SIZE"
    >   Right [Fetch [MessageId 2,UID 219,Size 4880],Fetch [MessageId 3,UID 411,Size 7392],...]

    That's where streaming comes in handy - if these were message bodies you would probably like to do something with them before all are downloaded.

    /Replies we didn't expect/

    IMAP protocol allows for messages pushed to the client at any time, even when they're not requested. This is used to notify the client that a new message had arrived, or as status of a message had changed as it was read by another client. These server messages wait for you in a bounded message queue and you can read them like:

    >    import qualified Data.STM.RollingQueue as RQ
    >    msgs <- atomically . RQ.read . untaggedQueue $ conn

    Where `conn` is the connection from previous step.

    /Streaming/

    There's <http://www.haskellforall.com/2014/11/how-to-build-library-agnostic-streaming.html an excellent article> by Gabriel Gonzalez you should read :)

category:             Network
abi:                  inplace
exposed:              True
exposed-modules:
    Network.IMAP Network.IMAP.Parsers Network.IMAP.Parsers.Fetch
    Network.IMAP.Parsers.Untagged Network.IMAP.Parsers.Utils
    Network.IMAP.RequestWatcher Network.IMAP.Types Network.IMAP.Utils

import-dirs:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/build

library-dirs:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/build

library-dirs-static:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/build

dynamic-library-dirs:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/build

data-dir:             /home/user/personal/imap/.
hs-libraries:         HSimap-0.3.0.8-inplace
depends:
    attoparsec-0.14.4-13094a5588dd4a269a796ed6ff1c82aa24f63e62c3189afadf55f94290789260
    base-4.17.2.1 bytestring-0.11.5.3 containers-0.6.7
    crypton-connection-0.4.1-ddb802a58398689d713a07f68305ed261efb3c1fcc99883903faf5e807726b29
    either-5.0.2-dfbc4a629107f2faf06c2208a8ffa49318a4dc42c1e69619c82a2a04b73b2e05
    exceptions-0.10.5
    hslogger-1.3.1.1-fcba9b07814c2c722b95fc5a98dfa90858936c73812808e72d08f5a3a62f27c4
    list-t-1.0.5.7-efdbc6805b68c049243a67faf1e73933e6845115179869a4f4b62210ef545162
    network-3.2.1.0-715112024df59ee31ac1537af873c2756fb7d40b9ebea4b066da70f9a399ca8c
    pipes-4.3.16-fd52e6b625b2456264961b00a1b2c6a865d81f5425b68a2087f1eb1cea342b0b
    random-1.2.1.2-b400976fe9b5de2c0b9ce1b58ddbb6eac6e4c3a7fa681744d604cb032214e84c
    rolling-queue-0.1-0059dc18d38ad560886723cc197fa98261f68efdb93d9b6f3f62b86214d7db58
    stm-2.5.1.0
    stm-delay-0.1.1.1-f0c79946f975352dcb3ce8739aaa6f938bc58433b848bdf7cfbdd50a0c1b89be
    text-2.0.2 transformers-0.5.6.2
    word8-0.1.3-61a923fa6bc4a76e2287a9dc75a3e10a0bc669f0d27d4da4640ae4b14dc7bf33

haddock-interfaces:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/doc/html/imap/imap.haddock

haddock-html:
    /home/user/personal/imap/dist-newstyle/build/x86_64-linux/ghc-9.4.8/imap-0.3.0.8/doc/html/imap
